(window.webpackJsonp=window.webpackJsonp||[]).push([[36],{354:function(n,e,t){"use strict";t.r(e);var a=t(1),r=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("div",{staticClass:"content"},[t("h4",{attrs:{id:"new的过程中操作了什么？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#new的过程中操作了什么？","aria-hidden":"true"}},[n._v("#")]),n._v(" new的过程中操作了什么？")]),n._v(" "),t("pre",[t("code",[n._v("var a = new Person('x','1');\nnew Person  {\n    var obj = {};\n    //创建一个对象\n    obj._proto_ = Person.prototype; \n    // 将新创建的空对象的隐式原型指向其构造函数的显示原型。\n    var result  = Person.call(obj,arguments);\n    //Person继承obj上边的参数也就是实参，并且改变this指向(因为call，apply，bind具有改变this的功能)\n    return typeof result === 'obj' ? result  :  obj;\n    //如果返回值是一个新对象的话那么直接直接返回该对象否则就返回形参\n}\n")])]),n._v(" "),t("h4",{attrs:{id:"普通函数与new-函数的区别？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#普通函数与new-函数的区别？","aria-hidden":"true"}},[n._v("#")]),n._v(" 普通函数与new  函数的区别？")]),n._v(" "),t("pre",[t("code",[n._v("function abc(){\n    let a = '1';\n    console.log(this.a);\n    console.log(a);\n}\n普通函数的调用abc(),返回结果是undefined(this指向了最后调用他的那个对象),1因为他里边的this是指向了最后调用他的那个对象\n当函数 new abc()之后,返回结果是undefined,1，因为此时new 之后函数返回的是实例对象，此时的实例对象里边没用this.a 所以返回undefined，里边的this指向了实例对象\n")])]),n._v(" "),t("h4",{attrs:{id:"null和undefined的区别？"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#null和undefined的区别？","aria-hidden":"true"}},[n._v("#")]),n._v(" null和undefined的区别？")]),n._v(" "),t("pre",[t("code",[n._v("当null和undefined比较的时候,是默认转换为bool\n(Bool(null) == false)  ==   (Bool(undefined) == true);\n是根据默认转换类型里边的第二条，且x为null  y为undefined的时候，返回true  ")])])])}],!1,null,null,null);e.default=r.exports}}]);